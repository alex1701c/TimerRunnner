//  Licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 2.1. See License in the project root for license information.
#include "timerrunner.h"
#include "core/utilities.h"

#include <QDBusConnection>
#include <QDBusArgument>
#include <QDBusMetaType>
#include <QDebug>
#include <iostream>
#include <KCoreAddons/KShell>
#include <KNotifications/KNotification>

// Generated by qt5_add_dbus_adaptor command im CMakeLists.txt file
#include "krunner1adaptor.h"

TimerRunner::TimerRunner()
{
    new Krunner1Adaptor(this);
    qDBusRegisterMetaType<RemoteMatch>();
    qDBusRegisterMetaType<RemoteMatches>();
    qDBusRegisterMetaType<RemoteAction>();
    qDBusRegisterMetaType<RemoteActions>();
    QDBusConnection::sessionBus().registerService(QStringLiteral("net.timerrunner2"));
    QDBusConnection::sessionBus().registerObject(QStringLiteral("/timerrunner"), this);

    timerQueryRegex = QRegularExpression("^timer (?<duration>\\d+)( ?(?<unit>[a-z]{1,3})( (?<msg>.+))?)?$");
    timerTimeQueryRegex =
        QRegularExpression("^timer (?<hours>\\d{1,2}):(?<minutes>\\d{2})(?<am_pm> ?am|pm)?( (?<name>.+))?$");
    timerQueryRegex.optimize();
    timerTimeQueryRegex.optimize();
}

TimerRunner::~TimerRunner()
{
    qDeleteAll(timers);
}

RemoteMatches TimerRunner::Match(const QString &searchTerm)
{
    if (!searchTerm.startsWith(triggerWord)) {
        return {};
    }
    RemoteMatches ms = displayTimers(searchTerm);
    const auto durationMatch = timerQueryRegex.match(searchTerm);
    const auto timeMatch = timerTimeQueryRegex.match(searchTerm);
    // Default entry
    if (durationMatch.hasMatch()) {
        ms.append(getDurationRemoteMatch(durationMatch));
    } else if (timeMatch.hasMatch()) {
        ms.append(getTimeRemoteMatch(timeMatch));
    } else {
        ms.append(getFallbackMatch());
    }

    return ms;
}

RemoteActions TimerRunner::Actions()
{
    return {RemoteAction({"cancel", "Cancel Timer", "gtk-quit"})};
}

void TimerRunner::Run(const QString &id, const QString &actionId)
{
    // action, isDuration=true, unit, time, name
    // action, isDuration=false, hours, minutes, am/pm, name
    const QStringList args = KShell::splitArgs(id);
    if (args.isEmpty()) {
        qWarning() << "List of arguments was empty";
        return;
    }
    if (actionId == QLatin1String("cancel")) {
        const auto timerPointerID = args.at(0).toLong();
        bool match = false;
        for (auto *timer: qAsConst(timers)) {
            if (reinterpret_cast<long>(timer) == timerPointerID) {
                timer->cancel();
                match = true;
            }
        }
        if (!match) {
            Utilities::showErrorNotification(QStringLiteral("Failed to cancel timer"));
        }
    } else if (args.first() == QLatin1String("new")) {
        auto *t = new Timer();
        // It is a duration match
        if (args.at(1) == QLatin1String("true")) {
            t->isDuration = true;
            t->initialUnit = args.at(2);
            t->initialValue = args.at(3).toInt();
            t->timer.start(Utilities::timeUnitToMSec(t->initialUnit, t->initialValue));
            t->name = args.at(2);
        }
            // Time match
        else {
            QTime time(args.at(2).toInt(), args.at(3).toInt());
            if (!time.isValid()) {
                Utilities::showErrorNotification(QStringLiteral("Invalid QTime object created!"));
                return;
            }
            if (time < QTime::currentTime()) {
                Utilities::showErrorNotification(QStringLiteral("The given time is smaller that the current time!"));
                return;
            }
            if (!args.at(4).isEmpty()) {
                if (args.at(4) == QLatin1String("pm")) {
                    if (time.hour() > 12) {
                        const auto err = QStringLiteral("In the 12 hour format the value can't be greater than 12!");
                        Utilities::showErrorNotification(err);
                        return;
                    }
                    time = QTime(time.hour() + 12, time.minute());
                }
            }
            t->isDuration = false;
            t->initialTime = time;
            t->initialTime = time;
            t->timer.start(QTime::currentTime().msecsTo(time));
            t->name = args.at(5);
        }
        connect(t, &Timer::isDone, this, &TimerRunner::removeTimer);
        timers.append(t);
    } else if (args.first() == QLatin1String("new-dislog")) {
       // TODO Create GUI dialog
    }
}

void TimerRunner::removeTimer()
{
    auto *timer = dynamic_cast<Timer *>(this->sender());
    if (timer) {
        timers.removeOne(timer);
        delete timer;
    }
}

RemoteMatch TimerRunner::getDurationRemoteMatch(const QRegularExpressionMatch &match)
{
    RemoteMatch m;
    int time = match.captured(QStringLiteral("duration")).toInt();
    QString unit = match.captured(QStringLiteral("unit"));
    // Default value
    if (time < 1 || unit.isEmpty()) {
        return getFallbackMatch();
    }
    const QString msg = match.captured(QStringLiteral("msg"));
    m.id = KShell::joinArgs({"new", "true", unit, QString::number(time), msg});
    QString displayText = QStringLiteral("Create new timer %1%2").arg(QString::number(time), unit);
    if (!msg.isEmpty()) {
        displayText = displayText.append(QStringLiteral(" \"%1\"")).arg(msg);
    }
    m.text = displayText;
    m.iconName = iconName;
    m.type = Plasma::QueryMatch::ExactMatch;
    m.relevance = 0.8;
    return m;
}

RemoteMatch TimerRunner::getTimeRemoteMatch(const QRegularExpressionMatch &match)
{
    RemoteMatch m;
    const QString hours = match.captured(QStringLiteral("hours"));
    const QString minutes = match.captured(QStringLiteral("minutes"));
    const QString amPM = match.captured(QStringLiteral("am_pm"));
    const QString name = match.captured(QStringLiteral("name"));
    QString displayText = QStringLiteral("Create new timer %1:%2%3").arg(hours, minutes, amPM);
    if (!name.isEmpty()) {
        displayText = displayText.append(QStringLiteral(" \"%1\"")).arg(name);
    }
    m.id = KShell::joinArgs({"new", "false", hours, minutes, amPM, name});
    m.text = displayText;
    m.iconName = iconName;
    m.type = Plasma::QueryMatch::ExactMatch;
    m.relevance = 0.8;
    return m;
}

RemoteMatches TimerRunner::displayTimers(const QString &searchTerm)
{
    RemoteMatches ms;
    // Overview
    if (searchTerm == triggerWord) {
        for (auto *timer: qAsConst(timers)) {
            if (timer->done) {
                continue;
            }
            RemoteMatch m;
            m.id = KShell::joinArgs({QString::number(reinterpret_cast<uintptr_t>(timer))});
            if (timer->isDuration) {
                const QString displayTime = Utilities::msecToTime(timer->timer.remainingTime());
                const QString displayName = timer->name.isEmpty() ? QStringLiteral("Timer") : timer->name;
                m.text = QStringLiteral("%1 %2 remaining").arg(displayName, displayTime);
            } else {
                m.text = timer->name + ' ' + timer->initialTime.toString("hh:mm");
            }
            if (timer->overdueTime.isValid()) {
                const QString display = Utilities::msecToTime(timer->overdueTime.msecsTo(QTime::currentTime()));
                m.text = m.text.append(QStringLiteral(" overdue for ") + display);
            }
            m.iconName = iconName;
            m.type = Plasma::QueryMatch::ExactMatch;
            m.relevance = 0.8;
            ms.append(m);
        }
    }
    return ms;
}

RemoteMatch TimerRunner::getFallbackMatch()
{
    RemoteMatch m;
    m.id = "new-dialog";
    m.text = QStringLiteral("Create New Timer");
    m.iconName = iconName;
    m.type = Plasma::QueryMatch::ExactMatch;
    m.relevance = 0.8;
    return m;
}
