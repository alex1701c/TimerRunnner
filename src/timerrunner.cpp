//  Licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 2.1. See License in the project root for license information.
#include "timerrunner.h"
#include "core/utilities.h"

#include <QDBusConnection>
#include <QDBusArgument>
#include <QDBusMetaType>
#include <QDebug>
#include <iostream>
#include <KCoreAddons/KShell>

// Generated by qt5_add_dbus_adaptor command im CMakeLists.txt file
#include "krunner1adaptor.h"

TimerRunner::TimerRunner()
{
    new Krunner1Adaptor(this);
    qDBusRegisterMetaType<RemoteMatch>();
    qDBusRegisterMetaType<RemoteMatches>();
    qDBusRegisterMetaType<RemoteAction>();
    qDBusRegisterMetaType<RemoteActions>();
    QDBusConnection::sessionBus().registerService(QStringLiteral("net.timerrunner2"));
    QDBusConnection::sessionBus().registerObject(QStringLiteral("/timerrunner"), this);

    timerQueryRegex =
        QRegularExpression(QStringLiteral("^timer (?<duration>\\d+)( ?(?<unit>[a-z]{1,3})( (?<msg>.+))?)?"));
    timerQueryRegex.optimize();
}

RemoteMatches TimerRunner::Match(const QString &searchTerm)
{
    if (!searchTerm.startsWith(triggerWord)) {
        return {};
    }
    RemoteMatches ms;
    // Overview
    if (searchTerm == triggerWord) {
        for (const auto *timer: qAsConst(timers)) {
            // TODO Remove from list or sth. else
            if (timer->done) {
                continue;
            }
            RemoteMatch m;
            m.id = timer->name;
            const QString displayTime = Utilities::msecToTime(timer->timer.remainingTime());
            const QString displayName = timer->name.isEmpty() ? QStringLiteral("Timer") : timer->name;
            m.text = QStringLiteral("%1 %2 remaining").arg(timer->name, displayTime);
            m.iconName = iconName;
            m.type = Plasma::QueryMatch::ExactMatch;
            m.relevance = 0.8;
            ms.append(m);
        }
    }
    const auto match = timerQueryRegex.match(searchTerm);
    // Default entry
    if (!match.hasMatch()) {
        RemoteMatch m;
        m.id = "new-dialog";
        m.text = QStringLiteral("New Timer");
        m.iconName = iconName;
        m.type = Plasma::QueryMatch::ExactMatch;
        m.relevance = 0.8;
        ms.append(m);
    } else {
        int time = match.captured(QStringLiteral("duration")).toInt();
        QString unit = match.captured(QStringLiteral("unit"));
        // Default value
        if (time < 1 || unit.isEmpty()) {
            time = defaultValue;
            unit = defaultUnit;
        }
        const int timeMillis = Utilities::timeUnitToMSec(unit, time);
        const QString msg = match.captured(QStringLiteral("msg"));
        RemoteMatch m;
        m.id = KShell::joinArgs({"new", QString::number(timeMillis), msg});
        QString displayText = QStringLiteral("Create new timer %1%2").arg(QString::number(time), unit);
        if (!msg.isEmpty()) {
            displayText = displayText.append(QStringLiteral(" \"%1\"")).arg(msg);
        }
        m.text = displayText;
        m.iconName = iconName;
        m.type = Plasma::QueryMatch::ExactMatch;
        m.relevance = 0.8;
        ms.append(m);
    }

    return ms;
}

RemoteActions TimerRunner::Actions()
{
    return RemoteActions();
}

void TimerRunner::Run(const QString &id, const QString &actionId)
{
    Q_UNUSED(actionId)

    const QStringList args = KShell::splitArgs(id);
    if (args.isEmpty()) {
        qWarning() << "List of arguments was empty";
        return;
    }
    if (args.first() == QLatin1String("new")) {
        auto *t = new Timer();
        t->timer.start(args.at(1).toInt());
        t->name = args.at(2);
        connect(t, &Timer::isDone, this, &TimerRunner::removeTimer);
        timers.append(t);
    }
}
void TimerRunner::removeTimer()
{
    auto *timer = dynamic_cast<Timer *>(this->sender());
    if (timer) {
        timers.removeOne(timer);
        delete timer;
    }
}
